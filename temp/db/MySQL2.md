# MySQL

## 锁

**按锁粒度分**

- **表锁**（MyISAM、MEMORY、BDB、InnoDB）
- **页锁**（BDB、InnoDB）

- **行锁**（InnoDB）
  - **记录锁**：即行级排它锁（SELECT … FOR UPDATE；上了记录锁）
  - **临键锁（RR隔离级别）**
  - **间隙锁（RR隔离级别）**

**按锁级别分**

- **共享锁（读锁）**：如果事务对数据 A 加上共享锁后，则其他事务只能对 A 再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据。（设置方法：SELECT … LOCK IN SHARE MODE）
- **排它锁（写锁）**：如果事务对数据 A 加上排他锁后，则其他事务不能再对 A 加任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据。（设置方法：SELECT … FOR UPDATE）
- **意向锁**：为了允许行锁和表锁的共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（自动加，不需要用户干预，都是表锁）
  - **意向共享锁（IS）**：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。
  - **意向排他锁（IX）**：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。

**间隙锁（Gap Locks）和临键锁（Next-Key Locks）**

​		间隙锁会锁定索引之间的间隙，但是不包含索引本身；临键锁是记录锁与间隙锁的组合，它的封锁范围，既包含索引记录，又包含索引区间（左开右闭）。

间隙锁和临键锁的作用：

1. 防止幻读。
2. 满足恢复和复制的需要。

案例数据

| id(主键) | c（普通索引） | d（无索引） |
| -------- | ------------- | ----------- |
| 5        | 5             | 5           |
| 10       | 10            | 10          |
| 15       | 15            | 15          |

​		为了解决幻读问题，MySQL 对上述的三条数据增加行锁，还对于中间的取值范围增加了 4 个间隙锁：（-∞，5）（5，10）（10，15）（15，+∞）。

1. 唯一索引只有在值存在时才是行锁，值不存在时，会降级成间隙锁。
2. 不同于写锁相互之间是互斥的原则，间隙锁之间不是互斥的，如果两个事务同时获得间隙锁。就可能会发生死锁问题。

**行锁的实现原理**

​		InnoDB的行锁是通过给**索引上的索引项加锁**实现的，一旦某个加锁操作没有使用到索引，那么该锁就会退化为表锁。注意以下两点：

1. MySQL的行锁是针对索引加的锁，**不是针对记录加的锁**，所以虽然是访问不同行的记录，但是如果是使用相同的索引值，也会出现锁冲突（即使用了相同的索引，查询的值也相同，但是不是相同的记录）。
2. 当表有多个索引的时候，事务通过索引锁定了某行数据时，其他事务不能通过该行数据其他字段上的索引锁定该行数据。

## 事务

### 事务的特性（ACID）

- **原子性**：一个事务被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚。

  实现原理：undo log 。

- **隔离性**：一个事务做的修改在最终提交前，对其他事务是不可见的。

  实现原理：锁实现了一个事务写操作对另一个事务写操作的隔离，MVCC 实现了一个事务写操作对另一个事务读操作的隔离。

- **持久性**：一旦事务提交，则其所做的修改就会永久保存到数据库中。

  实现原理：redo log 。

- **一致性**：数据库总是从一个一致性的状态转换到另外一个一致性的状态（事务只要最终没有提交，所做的修改也不会保存到数据库中）。

  实现原理：实现原子性、隔离性、持久性即实现一致性。

### 数据库的隔离级别

- **读未提交（Read Uncommitted）**：事务中的修改，即使没有提交，对其他事务也都是可见的。

  实现原理：事务对当前被读取的数据不加锁，都是当前读；事务在更新某数据时，必须先对其加行级共享锁，直到事务结束才释放。

- **读已提交（Read committed）**【大多数数据库的默认隔离级别】：一个事务从开始直到提交前，所做的任何修改对其他事务都是不可见的。

  应用场景：只增不改的业务环境（日志...）。

  实现原理：事务对当前被读取的数据加行级共享锁（当读到时才加锁），一旦读完该行，立即释放该行级共享锁；事务在更新某数据的瞬间，必须先对其加行级排他锁，直到事务结束才释放。

- **可重复读（Repeatable read）**【MySQL 的默认隔离级别】：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的且未提交的变更对其他事务也是不可见的。

  实现原理： 事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加行级共享锁，直到事务结束才释放；  事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加行级排他锁，直到事务结束才释放。

- **串行化（Serializable）**：对读取的每一行数据加锁。

  实现原理：事务在读取数据时，必须先对其加表级共享锁 ，直到事务结束才释放；事务在更新数据时，必须先对其加表级排他锁，直到事务结束才释放。

### 事务的并发问题

- **脏读**

  定义：事务可以读取其他事务未提交的数据。

  **解决方法**：修改时加排他锁（写锁），直到事务提交后才释放，读取时加共享锁(读锁)，其他事务只能读取，不能再有更新操作 。防止脏读。

- **不可重复读**

  定义：在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。通常针对数据更新（UPDATE）操作。

  **解决方法**：InnoDB 引擎采用了 MVCC 来解决不可重复读问题。MVCC 是利用在每条数据后面加了隐藏的两列（创建版本号和删除版本号）当执行查询的时, 当前查询版本号>= 创建版本号 并且 >删除版本号 , MVCC 可以在大多数情况下代替行级锁,使用 MVCC，能降低其系统开销。

- **幻读**

  定义：当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时产生了幻行。通常针对数据插入（INSERT）操作。

  **解决方法**：

  - 快照读（MVCC），普通的 select 就是快照读。将历史数据存一份快照，所以其他事务增加与删除数据，对于当前事务来说是不可见的。事务每次取数据的时候都会取创建版本<当前事务的数据，以及删除版本号码>当前版本的数据。
  - 当前读 执行数据库的增删改操作的时, 就是当前读采用next-key锁的方式解决问题，next-key 锁包含两部分: 记录锁（行锁）+ 间隙锁 就是在索引和索引之间上面加锁。

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
| -------- | ---- | ---------- | ---- |
| 读未提交 | Y    | Y          | Y    |
| 读已提交 | N    | Y          | Y    |
| 可重复读 | N    | N          | Y    |
| 串行化   | N    | N          | N    |

### MVCC 的实现原理

​		MVCC 的实现是通过保存数据正在某个时间点的快照（在每行记录后面保存两个隐藏的列（创建该行的系统版本号、使该行过期的系统版本号，类似乐观锁，每开始一个新事务，系统版本号都会字段递增））实现，MVCC 只在读已提交和可重复读这两个隔离级别工作（未提交读总是读取最新的数据行，而不是符合当前事务版本的数据行。而串行化则会对所有读取的行都加锁）。

- **SELECT（检查符合下面两个条件的每一行记录作为查询结果）**

  - InnoDB 只查找版本早于当前事务版本的数据行（行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前就存在的，要么是事务自身插入或者修改过的。
  - 行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。

- **INSERT**

  InnoDB为新插入的每一行保存当前系统版本号作为行版本号。

- **DELETE**

  InnoDB为删除的每一行保存当前系统版本号作为删除标识。

- **UPDATE**

  InnoDB为插入一行新纪录，保存当前系统版本作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。

**优缺点**

​		MVCC 使大多数读操作都可以不用加锁，这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。