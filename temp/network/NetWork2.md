# 网络

## TCP

### 三次握手

**位码**

- SYN（synchronous）： 发送/同步标志，用来建立连接，和下面的第二个标志位 ACK 搭配使用。连接开始时，SYN = 1，ACK = 0，代表连接开始但是未获得响应。当连接被响应的时候，标志位会发生变化，其中 ACK 会置为 1，代表确认收到连接请求，此时的标志位变成了 SYN = 1，ACK= 1；
- ACK（acknowledgement）：确认标志，表示确认收到请求；
- PSH（push） ：表示推送操作，就是指数据包到达接收端以后，不对其进行队列处理，而是尽可能的将数据交给应用程序处理；
- FIN（finish）：结束标志，用于结束一个 TCP 会话；
- RST（reset）：重置复位标志，用于复位对应的 TCP 连接；
- URG（urgent）：紧急标志，用于保证 TCP 连接不被中断，并且督促中间层设备尽快处理。

此外，还有两个序号：

- Sequence number ：顺序号，发送数据包中的第一个字节的序列号，一般为小写的 seq ；
- Acknowledge number：确认号，响应前面的 seq，值为 seq + 1，可以理解为期望下次发出的序列号为 seq + 1。

**简单过程**

- 客户端发送带有 SYN 标志的数据包到服务端（一次握手）

  客户端位码为 syn = 1，随机产生 seq number=1234567 的数据包到服务器，服务端由 syn = 1 知道客户端要求建立连接并进入 SYN_SENT 状态。

- 服务端发送带有 ACK/SYN 标志的数据包到客户端（二次握手）

  服务端收到请求后要确认联机信息，向客户端发送 ack number =（客户端的 seq + 1），syn = 1，ack = 1，随机产生 seq = 7654321 的包并进入 SYN_RECV 状态。

- 客户端发送带有带有 ACK 标志的数据包到服务端（三次握手）

  客户端收到后检查 ack number 是否正确，即第一次发送的 seq number + 1，以及位码 ack 是否为 1，若正确，客户端会再发送 ack number = （服务端的 seq + 1），ack = 1，服务端收到后确认 seq 值与 ac k= 1 则连接建立成功。此时客户端和服务端进入ESTABLISHED 状态。

**目的**：双方确认自己与对方的发送与接收是正常的。

**第三次握手失败怎么处理**

​		如果第三次握手失败（即服务端未收到ACK数据包），服务端会重新发送 SYN + ACK 包（重试机制），如果重传次数超过指定次数后仍未收到 ACK 应答，那么服务端会自动关闭这个连接。但是客户端认为这个连接已经建立，如果客户端向服务端写数据，服务端将以RST 包响应，此时客户端就能知道服务端的错误。

**为什么不是两次握手**

​		假如客户端发出的一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留以致延误到连接释放以后的某个时间才到达服务端，此时服务端误以为是新的连接请求，于是就向客户端发出确认报文段，同意建立连接。（二次握手只要服务端发出确认，新的连接就已建立），由于客户端实际并没有发出建立连接的请求，因此不会理睬服务端的确认，也不会向服务端发送数据，但服务端却以为新的运输连接已经建立，并一直等待客户端发来数据。

### 四次挥手

**简单过程**

- 客户端发送一个 FIN，用来关闭客户端到服务器的数据传送。
- 服务器收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号。
- 服务器关闭与客户端的连接，发送一个FIN给客户端。
- 客户端发回 ACK 报文确认，并将确认序号设置为收到序号加1。

任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。