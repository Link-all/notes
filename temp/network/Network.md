# 网络[[index]](https://github.com/Linkhhh/notes)

3. 进程间通信方式，共享内存怎么实现的
4. TCP通信相关步骤、函数
5. TCP协议哪些字段
6. 10、如果cookie禁用，如何保证单点登录？
7. .建立HTTP连接的三次握手的过程？，客户端和服务端分别是什么状态。讲一讲Http和Https的区别。
8. 、snmp
9. 11、http的长连接和短连接，谈谈你的理解？重定向和请求转发的区别？
10. TCP三次握手，除了ACK这种东西还有什么数据
11. TCP time_wait 什么时候出现
12. 简单描述一下http的七层协议
13. 、简单描述下tcp/ip的三次握手、四次挥手
14. 、ttp request的几种类型
15. Http怎么处理长连接
16. 、Cookie与Session的作用于原理
17. 访问一个网页，整个过程是怎么样的：DNS、HTTP、TCP、OSPF、IP、ARP
18. 主动关闭连接的一方需要维持此状态等待FIN信号，返回ACK
19. 使旧数据包在网络中过期（否则如果关闭后重新创建连接会无法辨别上个链接的数据导致错乱）
20. TCP三次握手四次挥手详细画出来
21. TPC、UDP、IP、套接字之间的关系
22. IP协议对应于网络层，TCP/UDP协议对应于传输层(解决如何传输)，而HTTP协议对应于应用层（解决如何包装数据）
23. 套接字（socket），是对TCP/IP协议的封装，提供调用接口
24. 输入一个URL按下回车发生了什么？
25. 像DNS服务器请求解析域名对应的IP地址
26. 建立HTTP连接，因为应用层的HTTP协议是基于网络层的TCP协议的，因此需要建立TCP连接（三次握手）
27. 发送http请求（该请求报文作为TCP三次握手的第三个报文传送给服务器）
28. 服务器对请求做出响应，返回HTML文本
29. 结束tcp连接（四次挥手） 浏览器解析HTML文本并显示
30. 8.HTTP 1.1版本增加了哪些内容？有哪几种请求方式？
31. 9.描述下HTTP三次握手和四次挥手过程？为什么需要四次挥手？为什么TIME_WAIT状态需要经过两个最大报文段生存时间才能到close状态？
32. 10.浏览器发起一个请求到收到响应中间经历了哪些过程？知道多少就说多少，越详细越好。
33. TCP 和 UDP 有什么区别?
34. 描述一下 TCP 四次挥手的过程中
35. TCP 有哪些状态
36. TCP 的 LISTEN 状态是什么
37. TCP 的 CLOSE_WAIT 状态是什么
38. 建立一个 socket 连接要经过哪些步骤
39. 常见的 HTTP 状态码有哪些
40. 301和302有什么区别
41. 504和500有什么区别
42. HTTPS 和 HTTP 有什么区别
43. 8.Socket编程 nio（这一块我不太熟就说没了解过，面试官就没细问了）
44. .HTTP 1.1版本增加了哪些内容？有哪几种请求方式？
45. 2.描述下HTTP三次握手和四次挥手过程？为什么需要四次挥手？为什么TIME_WAIT状态需要经过两个最大报文段生存时间才能到close状态？
46. 3.浏览器发起一个请求到收到响应中间经历了哪些过程？知道多少就说多少，越详细越好。
47. 31.Socket编程 nio（这一块我不太熟就说没了解过，面试官就没细问了）
48. 4、我看你简历里说熟悉计算机网络，来聊一聊计算机网络吧。了不了解tcp/udp，简单说下两者的区别？tcp为什么要三次握手和四次挥手？两次握手可以不？会有什么问题？
49. tcp怎么保证有序传输的，讲下tcp的快速重传和拥塞机制，知不知道time_wait状态，这个状态出现在什么地方，有什么用？
50. 、http与https有啥区别？https是怎么做到安全的？
51. 6.讲一讲计算机网络的三次握手和四次挥手？为什么要三次握手，两次可以不？
52. 2.计算机网络TCP的三次握手，UDP和TCP的区别。

- [1. OSI与TCP/IP体系结构](#1-OSI与TCPIP体系结构TOP)
  - [1.1. 各层的结构与功能？](#11-各层的结构与功能TOP)
  - [1.2. 各层有哪些协议？](#12-各层有哪些协议TOP)
  - [1.3 TCP、UDP、IP、套接字之间的关系？](#13-TCPUDPIP套接字之间的关系TOP)
- [2. TCP](#2-TCPTOP)
  - [2.1. TCP协议哪些字段？](#21-TCP协议哪些字段TOP)
  - [2.2. TCP三次握手](#22-TCP三次握手TOP)
    - [2.2.1. 简述TCP三次握手？（重要）](#221-简述TCP三次握手重要TOP)
    - [2.2.2. 第三次握手失败怎么处理？](#222-第三次握手失败怎么处理TOP)
    - [2.2.3. 为什么不是两次握手？](#223-为什么不是两次握手TOP)
  - [2.3. 简述TCP四次挥手？（重要）](#23-简述TCP四次挥手重要TOP)
  - [2.4. TCP和UDP的区别？](#24-TCP和UDP的区别TOP)
  - [2.5. 简述TCP通信步骤？](#25-简述TCP通信步骤TOP)
  - [2.6. TCP的状态](#26-TCP的状态TOP)
    - [2.6.1. 简述TCP的状态？](#261-简述TCP的状态TOP)
    - [2.6.2. TCP TIME_WAIT什么时候出现？](#262-TCP-TIME\_WAIT什么时候出现TOP)
    - [2.6.3. TCP TIME_WAIT有什么用？](#263-TCP-TIME\_WAIT有什么用TOP)
    - [2.6.4. 为什么TIME_WAIT状态需要经过两个最大报文段生存时间才能到close状态？](#264-为什么TIME\_WAIT状态需要经过两个最大报文段生存时间才能到close状态TOP)
    - [2.6.5. 大量TIME_WAIT有什么危害？](#265-大量TIME\_WAIT有什么危害TOP)
  - [2.7 TCP通信](#27-TCP通信TOP)
    - [2.7.1. 简述TCP通信步骤？](#271-简述TCP通信步骤TOP)
    - [2.7.2. TCP怎么保证有序传输的？](#272-TCP怎么保证有序传输的TOP)
    - [2.7.3. 简述TCP快速重传？](#273-简述TCP快速重传TOP)
    - [2.7.4. 简述TCP拥塞机制？](#274-简述TCP拥塞机制TOP)
- [3. HTTP](#3-HTTPTOP)
  - [3.1. HTTP和HTTPS的区别？](#31-HTTP和HTTPS的区别TOP)
  - [3.2. HTTP 1.0和HTTP 1.1的主要区别是什么?](#32-HTTP-10和HTTP-11的主要区别是什么TOP)
  - [3.3. 常见的状态码有哪些？](#33-常见的状态码有哪些TOP)
  - [3.4. HTTP怎么处理长连接？](#34-HTTP怎么处理长连接TOP)
  - [3.5.  输入一个URL按下回车发生了什么？](#35-输入一个URL按下回车发生了什么TOP)
  - [3.6. 重定向和请求转发的区别？](#36-重定向和请求转发的区别TOP)
- [4. Cookie和Session](#4-Cookie和SessionTOP)
  - [4.1. Cookie和Session的作用和区别？](#41-Cookie和Session的作用和区别TOP)
  - [4.2. 如果cookie禁用，如何保证单点登录？](#42-如果cookie禁用如何保证单点登录TOP)

## OSI与TCP/IP体系结构[[TOP]](#网络)
![image-20210329210900558](assert/osi-tcp-struct.png)

- 应用层：的任务是通过应用进程间的交互来完成特定网络应用。应用层交互的数据单元称为报文（HTTP协议、域名系统、FTP等等）；
- 表示层：加密解密、压缩解压缩、转换翻译；
- 会话层：不同机器上用户之间建立和管理会话（SSL、TSL、LDAP等）；
- 运输层：运输层的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务（TCP、UDP等）；
- 网络层：在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。*在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫IP数据报 ，简称数据报（ip协议）；
- 数据链路层：两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）；
- 物理层：在物理层上所传送的数据单位是比特。物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。

**TCP、UDP、IP、套接字之间的关系**

- IP协议对应于网络层；
- TCP/UDP协议对应于传输层（解决如何传输）；
- HTTP协议对应于应用层（解决如何包装数据）；
- 套接字（socket），是对TCP/IP协议的封装，提供调用接口。

## TCP[[TOP]](#网络)

**TCP协议字段**

![image-20210329213942383](assert/tcp-message-column.png)

- 16位端口号：告知主机该报文段是来自哪里（源端口）以及传给哪个上层协议或应用程序（目的端口）。
- 32位序号：一次TCP通信过程中的一个传输方向上的字节流的每个字节的编号。假设主机A和主机B进行TCP通信，A发送给B的第一个TCP报文段中，序号值被系统初始化为某个随机ISN（初始序号值）。那么在该传输方向上，后续的TCP报文段中序号值将被系统设置成ISN加上该报文段所携带数据的第一个字节在整个字节流中的偏移。
- 32位确认号：用作对另一个发送来的TCP报文段的响应。其值是收到的TCP报文段的序号值加1.假设主机A和主机B进行TCP通信，那么A发送出的TCP报文段不仅携带自己的序号，而且包含对主机B发送来的TCP报文段的确认号。反之，B发出的TCP报文段也同时携带自己的序号和对A发送来的报文段的确认号。
- 4位头部长度：标识该TCP头部有多少个32bit（4字节），四位最大表示15，所以TCP报头最长是60字节。
- 6位标志位
  URG:表示紧急指针是否有效。
  ACK:表示确认号是否有效。我们称携带ACK标志的TCP报文段为确认报文段。
  PSH:提示接收端应用程序应该立即从TCP接受缓冲区中读走数据，为接受后续数据腾出空间，如果不将接收到的数据读走，它们就会一直停留在TCP报文段。
  RST:表示要求对方重新建立连接。我们称携带RST标志的TCP报文段为复位报文段。
  SYN:表示请求建立一个新连接。称携带SYN标志位的TCP报文段为同步报文段。
  FIN:表示通知对方本端要关闭连接了。称携带FIN标志的TCP报文段为结束报文段。
- 16位窗口大小：这是TCP流量控制的一个手段。这里的窗口指的是接受通告的窗口。告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样就对方就可以控制发送数据的速度。
- 16位校验和：由发送端填充，接收端对TCP报文端执行CRC算法以检验TCP报文段在传输过程中是否损坏（检验部分包括报头和数据部分）。
- 16位紧急指针：为一个正的偏移量。它的序号字段的值相加表示最后一个紧急数据的下一个字节的序号。即紧急指针相对于当前序号的偏移。
- 剩下40字节为选项字段。

**TCP和UDP的区别**

1. TCP需要连接，UDP不需要。
2. TCP传输形式是字节流，UDP是数据报文段。
3. TCP传输可靠，数据传输慢，所需资源多，UDP相反（TCP在数据传递时，有确认、窗口、重传、拥塞、断开控制机制，不仅使协议数据单元的首部增大很多，还要占用许多处理机资源，难免增加了许多开销）。
4. 应用场景不同，TCP一般用于文件传输、发送和接收邮件、远程登录等可靠性高的场景；UDP一般用于即时通信、域名转换等通信速度要求高的场景。

**TCP通信步骤**

**服务器**

1. 调用 socket 函数创建 socket（侦听socket）；
2. 调用 bind 函数 将socket绑定到某个ip和端口的二元组上；
3. 调用 listen 函数开启侦听；
4. 当有客户端请求连接上来后，调用 accept 函数接受连接，产生一个新的 socket（客户端 socket）；
5. 基于新产生的 socket 调用 send 或 recv 函数开始与客户端进行数据交流；
6. 通信结束后，调用 close 函数关闭侦听 socket。

**客户端**

1. 调用 socket函数创建客户端 socket；
2. 调用 connect 函数尝试连接服务器；
3. 连接成功以后调用 send 或 recv 函数开始与服务器进行数据交流；
4. 通信结束后，调用 close 函数关闭侦听socket。

### TCP的状态

![image-20210330200534189](assert/tcp-transfer.png)

- CLOSED：初始状态，表示TCP连接是关闭着的或未打开的。
- LISTEN （服务端）：表示服务端的某个SOCKET处于监听状态，可以接受客户端的连接。
- SYN_SENT （客户端）：当客户端SOCKET执行connect()进行连接时，它首先发送SYN报文，然后随即进入到SYN_SENT 状态，并等待服务端的发送三次握手中的第2个报文（第一次握手）。
- SYN_RECV（服务端） ：表示服务器接收到了来自客户端请求连接的SYN报文。在正常情况下，这个状态很短暂，基本上用netstat很难看到这种状态；当TCP连接处于此状态时，再收到客户端的ACK报文，它就会进入到ESTABLISHED 状态（第二次握手）。
- ESTABLISHED ：表示TCP连接已经成功建立。
- FIN_WAIT_1 ：当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET进入到FIN_WAIT_1 状态（第一次挥手）。
- FIN_WAIT_2 ：当收到对方回应ACK报文后，则进入到FIN_WAIT_2状态。
- TIME_WAIT ：表示收到了对方的FIN报文，并发送出了ACK报文后进入到TIME_WAIT状态。TIME_WAIT状态下的TCP连接会等待2*MSL（Max Segment Lifetime，最大分段生存期，指一个TCP报文在Internet上的最长生存时间），然后即可回到CLOSED 可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（这种情况应该就是四次挥手变成三次挥手的那种情况）
- CLOSING ：一方发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。就会出现CLOSING 状态，表示双方都正在关闭SOCKET连接（双方同时关闭SOCKET）。
- CLOSE_WAIT ：表示收到了对方的FIN报文，并发送出了ACK报文后，检查自己是否还有数据要发送给对方，如果没有的话，你可以发送FIN报文给对方。简单地说，当你处于CLOSE_WAIT 状态下，需要完成的事情是等待你去关闭连接。
- LAST_ACK ：当被动关闭的一方在发送FIN报文后，等待对方的ACK报文的时候，就处于LAST_ACK 状态。当收到对方的ACK报文后，也就可以进入到CLOSED 可用状态了。

**TCP TIME_WAIT什么时候出现**

​		首先调用close()发起主动关闭的一方（主动方），在收到了对方的FIN报文并发送最后一个ACK之后会进入time_wait的状态。

**TCP TIME_WAIT有什么用**

- 可靠地实现TCP全双工连接的终止

  ​		保证客户端发送的最后一个ACK报文能够到达被动方。假设最终的ACK丢失，被动方将重发FIN，主动方必须维护TCP状态信息以便可以重发最终的ACK，否则会发送RST，结果被动方认为发生错误。TCP实现必须可靠地终止连接的两个方向(全双工关闭)，主动方必须进入 TIME_WAIT 状态，因为主动方可能面临重发最终ACK的情形。

- 允许老的报文在网络中消逝

  ​		防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。主动方发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。

**为什么TIME_WAIT状态需要经过两个最大报文段生存时间才能到close状态**

​		因为最后一个发送的ACK可能丢失，所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。被动方如果没有收到ACK，将不断重复发送FIN片段。所以主动方不能立即关闭，它必须确认被动方接收到了该ACK。如果直到2MSL，主动方都没有再次收到FIN，那么主动方推断ACK已经被成功接收，则结束TCP连接。

**大量TIME_WAIT有什么危害**

​		一个TCP/IP连接断开以后，会通过TIME_WAIT的状态保留一段时间，时间过了才会释放这个端口，当端口接受的频繁请求数量过多的时候，就会产生大量的TIME_WAIT状态的连接，这些连接占着端口，会消耗大量的资源。

### TCP通信

**TCP通信步骤**

- **服务器**
  1. 调用 socket 函数创建 socket（侦听socket）；
  2. 调用 bind 函数 将socket绑定到某个ip和端口的二元组上；
  3. 调用 listen 函数开启侦听；
  4. 当有客户端请求连接上来后，调用 accept 函数接受连接，产生一个新的 socket（客户端 socket）；
  5. 基于新产生的 socket 调用 send 或 recv 函数开始与客户端进行数据交流；
  6. 通信结束后，调用 close 函数关闭侦听 socket。
- **客户端**
  1. 调用 socket函数创建客户端 socket；
  2. 调用 connect 函数尝试连接服务器；
  3. 连接成功以后调用 send 或 recv 函数开始与服务器进行数据交流；
  4. 通信结束后，调用 close 函数关闭侦听socket。

**TCP怎么保证有序传输的**

​		主机每次发送数据时，TCP就给每个数据包分配一个序列号并且在一个特定的时间内等待接收主机对分配的这个序列号进行确认，如果发送主机在一个特定时间内没有收到接收主机的确认，则发送主机会重传此数据包。接收主机利用序列号对接收的数据进行确认，以便检测对方发送的数据是否有丢失或者乱序等，接收主机一旦收到已经顺序化的数据，它就将这些数据按正确的顺序重组成数据流并传递到高层进行处理。具体步骤如下：

1. 为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区；
2. 并为每个已发送的数据包启动一个超时定时器；
3. 如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区;
4. 否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。
5. 接收方收到数据包后，先进行CRC校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去。

**TCP快速重传**

​		即如果我连续收到3次dup ACK，发送方就认为这个seq的包丢失了，立刻进行重传，这样如果接收端回复及时的话，基本就是在重传定时器到期之前，提高了重传的效率。

**TCP拥塞机制**

​		TCP的拥塞机制解决的是网络延时突然增加，触发大量的数据重传，导致网络负担加重问题。TCP的拥塞控制主要依赖于一个 拥塞窗口(cwnd)来控制，窗口值的大小代表着能够发送出去的但还没有收到ACK(Acknowledgement确认字符)的最大数据报文段，显然窗口越大那么数据发送的速度也就越快，但是也越可能使得网络出现拥塞。

## HTTP[[TOP]](#网络)

**HTTP和HTTPS的区别**

- **端口** 

  ​		HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。

- **安全性和资源消耗**

  ​		HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP安全性没有 HTTPS高，但是 HTTPS比HTTP耗费更多服务器资源。

  - 对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；
  - 非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。

**HTTP 1.0和HTTP 1.1的区别**

- **长连接** 

  ​		HTTP 是基于TCP/IP协议的，每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。

  ​		因此从HTTP 1.1起，默认使用长连接 ,默认开启Connection： keep-alive。 HTTP/1.1的持续连接有非流水线方式和流水线方式 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。

- **错误状态响应码** 

  ​		在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

- **缓存处理** 

  ​		HTTP1.1则引入了更多可供选择的缓存头来控制缓存策略。

- **带宽优化及网络连接的使用** 

  ​		HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。

**常见的HTTP状态码**

- 1XX （信息性状态码，接受的请求正在处理）	

- 2XX（成功状态码，请求正常处理完毕）
  - 200[OK]：请求已正常处理。
  - 204[No Content]：请求处理成功，但没有任何资源可以返回给客户端，一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。
- 3XX（重定向状态码，需要进行附加操作以完成请求）
- 4XX（客户端错误状态码，服务器无法处理请求）
  - 400[Bad Request]：服务器端无法理解客户端发送的请求，请求报文中可能存在语法错误。
  - 401[Unauthorized]：该状态码表示发送的请求需要有通过HTTP认证（BASIC认证，DIGEST认证）的认证信息。
  - 403[Forbidden]：不允许访问那个资源。该状态码表明对请求资源的访问被服务器拒绝了。（权限，未授权IP等）
  - 404[Not Found]：服务器上没有请求的资源。路径错误等。
- 5XX（服务器错误状态码，服务器处理请求出错）
  - 500[Internal Server Error]：貌似内部资源出故障了。该状态码表明服务器端在执行请求时发生了错误。也有可能是web应用存在bug或某些临时故障。

**HTTP怎么处理长连接**

​		从 HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码：`Connection:keep-alive`

　　在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。

**输入一个URL按下回车发生了什么**

1. 浏览器查找域名对应的IP地址（DNS解析：浏览器缓存、路由器缓存、DNS缓存）；
2. TCP连接；
3. 浏览器向web服务器发送HTTP请求；
4. 服务器处理请求并返回HTTP报文；
5. 浏览器解析渲染页面；
6. 连接结束。

**重定向和请求转发的区别**

- **forward（转发）**

  ​		是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容从哪里来的，因为这个跳转过程实在服务器实现的，并不是在客户端实现的所以客户端并不知道这个跳转动作，所以它的地址栏还是原来的地址。

- **redirect（重定向）**

  ​		是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL。

区别：

- 从地址栏显示来说，转发是原来的请求地址，重定向是新地址。
- 从数据共享来说，转发页面和转发到的页面可以共享request里面的数据，重定向不能共享（新的请求）。
- 转发是服务器行为，重定向是客户端行为。
- 重定向是两次请求，效率低。
- 转发一般用于用户登录后跳转，重定向一般用于注销登录或者未登录重定向到登录页面。

## Cookie和Session[[TOP]](#网络)

**Cookie**

​		Cookie一般用来保存用户信息且数据保存在客户端(浏览器端)。

**Session**

​		Session的主要作用就是通过服务端记录用户的状态且数据保存在服务器端。

> 如果cookie禁用，如何保证单点登录？
>
> 通过Http请求头或url后面加参数的方式来传递SessionID。

